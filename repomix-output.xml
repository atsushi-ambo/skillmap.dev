This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  img/
    icons/
      cloud.svg
      cost.svg
      monitor.svg
      network.svg
      scale.svg
  ops-essentials/
    index.md
    level1.md
    level2.md
    level3.md
    level4.md
  index.md
ops-essentials/
  games/
    01-network/
      checker.py
      docker-compose.yml
      nginx.conf
      quest.md
    02-monitor/
      app.py
      checker.py
      docker-compose.yml
      Dockerfile.flask
      prometheus.yml
      quest.md
      requirements.txt
    03-backup/
      checker.py
      docker-compose.yml
      quest.md
      redis-init.sh
      redis.conf
    04-ha/
      haproxy.cfg
tools/
  cli/
    game.py
.gitignore
docker-compose.yml
mkdocs.yml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/img/icons/cloud.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>
</file>

<file path="docs/img/icons/cost.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20"></path><path d="M2 8h20"></path><path d="M2 16h20"></path><path d="M6 6h12v12H6z"></path></svg>
</file>

<file path="docs/img/icons/monitor.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
</file>

<file path="docs/img/icons/network.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>
</file>

<file path="docs/img/icons/scale.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18"></path><path d="M2 12h20"></path><path d="M18 6l-4 4-4-4"></path><path d="M6 18l4-4 4 4"></path></svg>
</file>

<file path="docs/ops-essentials/index.md">
# Ops Essentials

![Cloud Icon](../img/icons/cloud.svg){ .icon style="color:#3B82F6" }

クラウドネイティブなインフラ運用の基礎を学ぶコースです。

## コース構成

1. **Foundations** - インフラ主要コンポーネントとネットワーク基礎
2. **Ops Routine** - 監視、ログ、バックアップの基本
3. **Scale & HA** - スケーリングと高可用性の基本
4. **Design & Cost** - コスト最適化と設計パターン

## 学習方法

各レベルは以下の構成になっています：

- **学習目標** - そのレベルで習得すべきスキル
- **主要コンセプト** - 重要な概念の説明
- **ハンズオン** - 実際に手を動かす演習
- **チェックポイント** - 理解度確認のためのクイズ

## 必要な環境

- 最新のウェブブラウザ
- Docker と Docker Compose が動作する環境（ハンズオン用）
- ターミナル（コマンドライン）の基本的な操作知識

[Level 1 を始める →](level1.md){ .md-button .md-button--primary }
</file>

<file path="docs/ops-essentials/level1.md">
# Level 1 — Foundations { #level1 }
![Network Icon](../img/icons/network.svg){ .icon style="color:#3B82F6" }

!!! abstract "学習ゴール"
    1. インフラ主要コンポーネントを説明できる  
    2. HTTP/DNS/SSL の役割を理解する  
    3. ハンズオン環境を操作できる

## コンポーネント早見表

| カテゴリ | 代表例 | ひとことで言うと |
|---|---|---|
| **Web Server** | Nginx, Apache | HTTPリクエストを処理する |
| **App Server** | Gunicorn, uWSGI | アプリケーションを実行する |
| **Database** | PostgreSQL, MySQL | 構造化データを永続化 |
| **KVS** | Redis | メモリ特化の辞書 |
| **Queue** | RabbitMQ | メッセージの行列 |
| **CDN** | CloudFront | 静的キャッシュ網 |

## ネットワーク基礎

### HTTP/HTTPS
- **HTTP (80)**: ウェブ通信の基本プロトコル
- **HTTPS (443)**: 暗号化されたHTTP通信

```mermaid
graph LR
  Client -->|HTTPS| LB[Load Balancer]
  LB -->|HTTP| Web1[Web Server 1]
  LB -->|HTTP| Web2[Web Server 2]
```

!!! info "用語ノート"
    ポート番号は "アプリの玄関"。HTTP=80, HTTPS=443 が標準。

### DNS の仕組み
1. ブラウザがDNSサーバーに問い合わせ
2. ドメイン名 → IPアドレス に変換
3. 接続先が決定

## ハンズオン: 初めてのWebサーバー

!!! warning "Lab 01 - Webサーバーを立ててみよう"
    Docker Compose で Nginx を起動し、ブラウザで確認します。

```bash
docker compose up -d web
```

ブラウザで `http://localhost:8080` にアクセスしてみましょう。

## 章末チェック

???+ quiz "理解度チェック"
    ? DNS が解決するのは？
    - [ ] OS バージョン
    - [x] ホスト名 → IP
    - [ ] TCP ポート
    - [ ] CPU 温度

    ? HTTPSの標準ポート番号は？
    - [ ] 80
    - [x] 443
    - [ ] 22
    - [ ] 3306

[次のレベルへ →](../ops-essentials/level2.md){ .md-button }
</file>

<file path="docs/ops-essentials/level2.md">
# Level 2 — Ops Routine { #level2 }
![Monitor Icon](../img/icons/monitor.svg){ .icon style="color:#10B981" }

!!! abstract "学習ゴール"
    1. システム監視の基本を理解する  
    2. ログ管理の重要性を学ぶ  
    3. バックアップ戦略を設計できる

## 監視の基本

### 監視の4つの観点
1. **リソース監視** (CPU, メモリ, ディスク)
2. **サービス監視** (HTTP, TCP)
3. **ログ監視** (エラーログ, アクセスログ)
4. **ビジネスKPI** (リクエスト数, エラー率)

## ハンズオン: 監視システムの構築

!!! warning "Lab 02 - 監視システムを構築しよう"
    Prometheus と Grafana をセットアップします。

```bash
docker compose up -d prometheus grafana
```

Grafana にログインして、ダッシュボードを確認しましょう。

[次のレベルへ →](../ops-essentials/level3.md){ .md-button }
</file>

<file path="docs/ops-essentials/level3.md">
# Level 3 — Scale & HA { #level3 }
![Scale Icon](../img/icons/scale.svg){ .icon style="color:#F59E0B" }

!!! abstract "学習ゴール"
    1. スケーリングの基本を理解する  
    2. 高可用性の仕組みを学ぶ  
    3. ロードバランサーを設定できる

## スケーリング戦略

### スケールアップ vs スケールアウト
- **スケールアップ**: サーバーのリソースを増強
- **スケールアウト**: サーバー台数を増やして分散

## ハンズオン: ロードバランサー

!!! warning "Lab 03 - ロードバランサーを設定しよう"
    HAProxy を使って複数インスタンスに負荷分散します。

```bash
docker compose up -d --scale app=3 haproxy
```

[次のレベルへ →](../ops-essentials/level4.md){ .md-button }
</file>

<file path="docs/ops-essentials/level4.md">
# Level 4 — Design & Cost { #level4 }
![Cost Icon](../img/icons/cost.svg){ .icon style="color:#EC4899" }

!!! abstract "学習ゴール"
    1. クラウドコストの最適化手法を学ぶ  
    2. コスト効率の良い設計ができる  
    3. コスト監視の仕組みを理解する

## コスト最適化の基本

### コスト削減のポイント
- 使っていないリソースの削除
- 適切なサイジング
- リザーブドインスタンスの活用
- スポットインスタンスの活用

## ハンズオン: コスト分析

!!! warning "Lab 04 - コスト分析をしよう"
    AWS Cost Explorer のようなツールでコスト分析を行います。

```bash
# コスト分析スクリプトを実行
python3 analyze_cost.py
```

## おめでとうございます！

これで Ops Essentials コースは完了です！

[← コース一覧に戻る](../index.md){ .md-button }
</file>

<file path="docs/index.md">
# Skillmap.dev

> 学習ロードマップと "手を動かす" ハンズオンを一か所に。

<div style="text-align:center">
  <img src="img/icons/cloud.svg" width="80">
</div>

## いま読めるコンテンツ

<div class="grid cards" markdown>

- **Ops Essentials** – インフラ運用の基礎からコスト設計まで  
  [Ops Essentials](ops-essentials/index.md)

- **Coming Soon** – 準備中  
  コンテンツを鋭意制作中です

</div>
</file>

<file path="ops-essentials/games/01-network/checker.py">
#!/usr/bin/env python3
import sys
import urllib.request
import urllib.error
import socket
import json
from typing import Tuple, Dict, Any

def check_ports() -> bool:
    """Check if the port mapping is correct by inspecting the container."""
    import subprocess
    try:
        # Get the container's port mapping
        cmd = [
            'docker', 'inspect',
            '--format', '{{range $p, $conf := .NetworkSettings.Ports}}{{$p}} -> {{(index $conf 0).HostPort}}{{"\n"}}{{end}}',
            'skillmapdev-network_lab-1'
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        print("\n🔍 現在のポートマッピングを確認中...")
        print(result.stdout.strip())
        
        # Check if port 80 is mapped to 8080
        if '80/tcp -> 8080' in result.stdout:
            print("✅ ポートマッピングが正しく設定されています (80/tcp -> 8080)")
            return True
        else:
            print("❌ ポートマッピングが正しく設定されていません")
            print("   期待されるマッピング: 80/tcp -> 8080")
            return False
            
    except subprocess.CalledProcessError as e:
        print(f"❌ コンテナ情報の取得に失敗しました: {e}")
        return False
    except Exception as e:
        print(f"❌ エラーが発生しました: {e}")
        return False

def check_nginx() -> Tuple[bool, Dict[str, Any]]:
    """Check if Nginx is responding correctly."""
    try:
        # Check if nginx is accessible on port 8080
        req = urllib.request.Request(
            'http://localhost:8080',
            headers={'User-Agent': 'Skillmap Exercise Checker'}
        )
        
        with urllib.request.urlopen(req, timeout=5) as response:
            content = response.read().decode('utf-8')
            headers = dict(response.getheaders())
            
            return True, {
                'status': response.status,
                'content': content,
                'headers': headers
            }
            
    except urllib.error.HTTPError as e:
        return False, {'error': f'HTTP Error: {e.code} - {e.reason}'}
    except urllib.error.URLError as e:
        if isinstance(e.reason, socket.timeout):
            return False, {'error': 'Request timed out. Is Nginx running?'}
        return False, {'error': f'URL Error: {e.reason}'}
    except Exception as e:
        return False, {'error': f'An error occurred: {str(e)}'}

def check_network() -> bool:
    """Check if the network setup is correct."""
    print("🚀 ネットワーク設定を確認中...\n")
    
    # First check the port mapping
    if not check_ports():
        print("\n❌ ポートマッピングを確認してください。")
        print("   docker-compose.yml の ports 設定を確認し、正しいマッピングに修正してください。")
        print("   例: \"8080:80\" (ホスト:コンテナ)")
        return False
    
    # Then check Nginx response
    success, result = check_nginx()
    
    if success:
        print("\n🔄 Nginx の応答を確認中...")
        print(f"   Status: {result['status']}")
        print(f"   Content-Type: {result['headers'].get('Content-Type', 'N/A')}")
        print(f"   X-Network-Exercise: {result['headers'].get('X-Network-Exercise', 'N/A')}")
        
        if 'おめでとう' in result['content']:
            print("\n🎉 おめでとうございます！Nginx が正しく設定されました！")
            print("✅ 演習は成功です！")
            return True
        else:
            print("\n❌ Nginx の応答が期待と異なります。")
            print("   nginx.conf の設定を確認してください。")
            return False
    else:
        print("\n❌ Nginx への接続に失敗しました。")
        print(f"   エラー: {result['error']}")
        print("\nトラブルシューティングのヒント:")
        print("1. コンテナが起動しているか確認: docker ps")
        print("2. Nginx のログを確認: docker logs skillmapdev-network_lab-1")
        print("3. ポートが使用中でないか確認: lsof -i :8080")
        return False

if __name__ == "__main__":
    success = check_network()
    sys.exit(0 if success else 1)
</file>

<file path="ops-essentials/games/01-network/docker-compose.yml">
version: "3.9"
services:
  nginx:
    image: nginx:1.25-alpine
    ports:
      - "8080:8000"  # Intentionally misconfigured port mapping
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
</file>

<file path="ops-essentials/games/01-network/nginx.conf">
# This is a basic Nginx configuration file
# It defines how the web server handles incoming requests

events {
    # Maximum number of simultaneous connections per worker process
    worker_connections 1024;
}

http {
    # Define a virtual server
    server {
        # Listen on port 8000 for IPv4 and IPv6
        listen 8000;
        
        # Server name (domain)
        server_name localhost;
        
        # Default location block
        location / {
            # Return a simple text response
            return 200 '🎉 おめでとうございます！Nginx が正しく設定されました！\n\n' 
                       '✅ ポートマッピングが正しく設定されました。\n' 
                       'Nginx はコンテナ内のポート 8000 でリッスンしており、\n' 
                       'ホストマシンのポート 8080 からアクセスできます。\n\n' 
                       'このメッセージが表示されたら、演習は成功です！';
            
            # Set the content type to plain text
            add_header Content-Type text/plain;
            
            # Add a custom header for educational purposes
            add_header X-Network-Exercise "Completed";
        }
    }
}
</file>

<file path="ops-essentials/games/01-network/quest.md">
# ネットワーク設定のデバッグ演習

## 演習の目的
この演習では、Docker のネットワーク設定とポートマッピングについて学びます。
コンテナ内で動作するアプリケーションに、ホストマシンからアクセスするための基本的な設定方法を理解します。

## 課題
Nginx ウェブサーバーが正しく動作するように、`docker-compose.yml` ファイルを修正してください。

## 現在の状態
- Nginx はコンテナ内の 8000 番ポートでリッスンするように設定されています
- しかし、`docker-compose.yml` のポートマッピングが正しく設定されていないため、ホストマシンからアクセスできません

## 目標
1. `docker-compose.yml` を編集して、ホストマシンの 8080 番ポートが Nginx コンテナの 8000 番ポートに正しくマッピングされるようにする
2. 修正後、以下のコマンドで動作確認する
   ```bash
   python3 tools/cli/game.py play 01-network
   ```

## ステップバイステップガイド

1. まず、`docker-compose.yml` ファイルを開いてください
   ```bash
   code ops-essentials/games/01-network/docker-compose.yml
   ```

2. `ports` セクションを確認します。現在は以下のようになっています：
   ```yaml
   ports:
     - "8080:8000"  # 意図的に間違ったマッピング
   ```

3. ポートマッピングのフォーマットは `ホストポート:コンテナポート` です。
   Nginx はデフォルトで 80 番ポートでリッスンするため、コンテナポートを 80 に変更します。

4. 以下のように修正してください：
   ```yaml
   ports:
     - "8080:80"  # ホストの8080 → コンテナの80
   ```

5. 変更を保存したら、以下のコマンドでコンテナを再起動します：
   ```bash
   docker compose --profile game down
   docker compose --profile game up -d
   ```

6. 最後に、以下のコマンドで正しく修正できたか確認します：
   ```bash
   python3 tools/cli/game.py play 01-network
   ```

## ヒント
- `docker ps` コマンドで、コンテナのポートマッピングを確認できます
- `curl -v http://localhost:8080` で、Nginx の応答を直接確認できます
- 問題が解決しない場合は、Nginx のログを確認してみてください：
  ```bash
  docker logs skillmapdev-network_lab-1
  ```

## 発展課題（余裕があれば挑戦してみてください）
- ホストマシンの異なるポート（例: 8081）で Nginx にアクセスできるように設定を変更してみてください
- Nginx の設定ファイル (`nginx.conf`) を編集して、カスタムのウェルカムメッセージを表示するように変更してみてください
</file>

<file path="ops-essentials/games/02-monitor/app.py">
from flask import Flask, jsonify
import random
import time

app = Flask(__name__)

# Simple counter for requests
request_counter = 0

@app.route('/')
def home():
    global request_counter
    request_counter += 1
    return jsonify({
        'status': 'running',
        'request_count': request_counter,
        'timestamp': time.time()
    })

@app.route('/metrics')
def metrics():
    return f"""# HELP http_requests_total Total number of HTTP requests
# TYPE http_requests_total counter
http_requests_total {request_counter}
"""

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
</file>

<file path="ops-essentials/games/02-monitor/checker.py">
#!/usr/bin/env python3
"""
Prometheus ターゲットチェッカー

このスクリプトは、Prometheus のターゲットが正しく設定され、
アプリケーションのメトリクスが収集されているかを確認します。
"""

import json
import sys
import urllib.request
import urllib.error
import socket
from typing import Dict, Any, List, Optional

def get_prometheus_targets() -> Dict[str, Any]:
    """Prometheus のターゲット情報を取得する"""
    try:
        url = "http://prometheus:9090/api/v1/targets"
        req = urllib.request.Request(url)
        
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode('utf-8'))
            return data
    except urllib.error.HTTPError as e:
        return {"error": f"HTTP Error: {e.code} - {e.reason}"}
    except urllib.error.URLError as e:
        if isinstance(e.reason, socket.timeout):
            return {"error": "Request timed out. Is Prometheus running?"}
        return {"error": f"URL Error: {e.reason}"}
    except Exception as e:
        return {"error": f"An error occurred: {str(e)}"}

def check_flask_target(targets_data: Dict[str, Any]) -> bool:
    """Flask アプリケーションのターゲットが正しく設定されているか確認"""
    if "data" not in targets_data or "activeTargets" not in targets_data["data"]:
        print("❌ ターゲット情報を取得できませんでした")
        return False
    
    active_targets = targets_data["data"]["activeTargets"]
    flask_targets = [t for t in active_targets if t["scrapePool"] == "flask_app"]
    
    print("\n🔍 現在の Prometheus ターゲット状態:")
    print("-" * 50)
    
    if not flask_targets:
        print("❌ flask_app のターゲットが見つかりません")
        return False
    
    all_healthy = True
    for target in flask_targets:
        status = "✅ UP" if target["health"] == "up" else "❌ DOWN"
        print(f"{status} - {target['scrapeUrl']} (Job: {target['scrapePool']})")
        
        if target["health"] != "up":
            print(f"   エラー: {target.get('lastError', 'No error details')}")
            all_healthy = False
    
    return all_healthy

def check_metrics_are_being_collected() -> bool:
    """メトリクスが収集されているか確認"""
    try:
        # メトリクスが収集されているか確認
        url = "http://prometheus:9090/api/v1/query?query=http_requests_total"
        req = urllib.request.Request(url)
        
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode('utf-8'))
            
            if data["status"] != "success":
                print("❌ メトリクスクエリが失敗しました")
                return False
                
            if not data["data"]["result"]:
                print("❌ メトリクスが収集されていません")
                return False
                
            print("\n📊 メトリクス収集状況:")
            print("-" * 30)
            print(f"✅ メトリクスが正常に収集されています")
            for result in data["data"]["result"][:3]:  # 最初の3件のみ表示
                print(f"  - {result['metric'].get('job', 'unknown')}: {result['value'][1]} (at {result['value'][0]})")
            
            return True
            
    except Exception as e:
        print(f"❌ メトリクスの確認中にエラーが発生しました: {str(e)}")
        return False

def main() -> None:
    """メイン処理"""
    print("🚀 Prometheus ターゲットチェックを開始します...")
    
    # 1. Prometheus からターゲット情報を取得
    print("\n🔍 Prometheus からターゲット情報を取得中...")
    targets_data = get_prometheus_targets()
    
    if "error" in targets_data:
        print(f"❌ エラー: {targets_data['error']}")
        print("\n💡 トラブルシューティングのヒント:")
        print("1. Prometheus が起動しているか確認: docker ps | grep prometheus")
        print("2. Prometheus のログを確認: docker compose logs prometheus")
        print("3. ネットワーク設定を確認: docker network ls と docker network inspect")
        sys.exit(1)
    
    # 2. Flask アプリケーションのターゲットを確認
    print("\n🔍 Flask アプリケーションのターゲットを確認中...")
    if not check_flask_target(targets_data):
        print("\n❌ ターゲットの設定に問題があります")
        print("\n💡 修正のヒント:")
        print("1. prometheus.yml の targets が正しいか確認")
        print("   - 現在: ['localhost:9999']")
        print("   - 期待: ['flask_app:5000']")
        print("2. 修正後、docker compose restart prometheus で再起動")
        sys.exit(1)
    
    # 3. メトリクスが収集されているか確認
    print("\n🔍 メトリクスの収集状況を確認中...")
    if not check_metrics_are_being_collected():
        print("\n❌ メトリクスが正しく収集されていません")
        print("\n💡 トラブルシューティングのヒント:")
        print("1. Flask アプリケーションが起動しているか確認: docker ps | grep flask")
        print("2. Flask アプリケーションのログを確認: docker compose logs flask_app")
        print("3. http://localhost:5000/metrics にアクセスしてメトリクスが表示されるか確認")
        sys.exit(1)
    
    # すべてのチェックに成功
    print("\n" + "=" * 50)
    print("✅ おめでとうございます！すべてのチェックに成功しました！")
    print("=" * 50)
    print("\n🎯 学習のポイント:")
    print("- Prometheus のターゲット設定を理解しました")
    print("- メトリクスの収集方法を学びました")
    print("- 監視システムの設定とデバッグ方法を実践しました")
    
    sys.exit(0)

if __name__ == "__main__":
    main()
</file>

<file path="ops-essentials/games/02-monitor/docker-compose.yml">
version: '3.8'

services:
  flask_app:
    build:
      context: .
      dockerfile: Dockerfile.flask
    ports:
      - "5000:5000"
    networks:
      - monitor_net
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    networks:
      - monitor_net
    depends_on:
      - flask_app

networks:
  monitor_net:
    driver: bridge

volumes:
  prometheus_data:
</file>

<file path="ops-essentials/games/02-monitor/Dockerfile.flask">
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 5000

CMD ["python", "app.py"]
</file>

<file path="ops-essentials/games/02-monitor/prometheus.yml">
global:
  scrape_interval: 5s
  evaluation_interval: 5s

scrape_configs:
  - job_name: 'flask_app'
    static_configs:
      - targets: ['localhost:9999']  # 意図的に間違ったポート

  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
</file>

<file path="ops-essentials/games/02-monitor/quest.md">
# モニタリング設定のデバッグ

## 演習の目的
この演習では、Prometheus を使ったアプリケーションの監視設定を学びます。
間違った設定を正しく修正して、アプリケーションのメトリクスが正しく収集されるようにします。

## 現在の状況

- Flask アプリケーションが `http://flask_app:5000` で動作しています
- Prometheus が `http://localhost:9090` で動作しています
- しかし、Prometheus のターゲットがダウンした状態になっています

## 課題

1. Prometheus の設定ファイル (`prometheus.yml`) を修正して、Flask アプリケーションのメトリクスを収集できるようにしてください
2. 修正後、Prometheus のターゲットページで `flask_app` が `UP` 状態になっていることを確認してください

## ステップバイステップガイド

1. まず、現在の設定を確認してください:
   ```bash
   cat prometheus.yml
   ```

2. 問題点を特定してください:
   - Flask アプリケーションは `flask_app:5000` で動作しています
   - しかし、Prometheus は `localhost:9999` を監視しようとしています

3. `prometheus.yml` を編集して、正しいターゲットを設定してください:
   ```yaml
   - job_name: 'flask_app'
     static_configs:
       - targets: ['flask_app:5000']  # ここを修正
   ```

4. 変更を適用するために、Prometheus を再起動してください:
   ```bash
   docker compose restart prometheus
   ```

5. Prometheus の Web UI でステータスを確認:
   - http://localhost:9090/targets にアクセス
   - `flask_app` のステータスが `UP` になっていることを確認

6. メトリクスが収集されているか確認:
   - http://localhost:9090/graph にアクセス
   - クエリフィールドに `http_requests_total` と入力
   - グラフが表示されれば成功

## ヒント

- Prometheus はコンテナ間で通信するため、サービス名をホスト名として使用できます
- ポート番号は、アプリケーションが実際にリッスンしているポートと一致させる必要があります
- 変更後は必ず Prometheus を再起動してください

## 確認方法

演習が完了したら、以下のコマンドで正しく設定できたか確認できます:

```bash
python3 ../../../../tools/cli/game.py play 02-monitor
```

## 発展課題（余裕があれば挑戦してみてください）

- Prometheus のアラートルールを追加してみましょう
- Grafana を追加して、ダッ�ボードを作成してみましょう
- カスタムメトリクスを追加して、Prometheus で収集してみましょう
</file>

<file path="ops-essentials/games/02-monitor/requirements.txt">
flask==2.0.1
prometheus-client==0.12.0
</file>

<file path="ops-essentials/games/03-backup/checker.py">
#!/usr/bin/env python3
"""
Redis バックアップチェッカー

このスクリプトは、Redis のバックアップ設定が正しく行われているかを確認します。
"""

import subprocess
import json
import sys
import time
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, Tuple

def run_command(cmd: str) -> Tuple[bool, str]:
    """コマンドを実行して結果を返す"""
    try:
        result = subprocess.run(
            cmd, 
            shell=True, 
            check=True, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            text=True
        )
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, f"Command failed with error: {e.stderr}"

def check_redis_running() -> bool:
    """Redis が実行中か確認"""
    print("\n🔍 Redis の実行状態を確認中...")
    success, output = run_command("docker compose ps redis | grep Up")
    
    if not success or "redis" not in output:
        print("❌ Redis が実行されていません")
        print("💡 以下のコマンドで起動してください: docker compose up -d")
        return False
    
    print("✅ Redis が正常に実行されています")
    return True

def check_redis_config() -> Dict[str, Any]:
    """Redis の設定を確認"""
    print("\n🔍 Redis の設定を確認中...")
    
    # 設定ファイルの内容を取得
    success, output = run_command("docker compose exec redis cat /usr/local/etc/redis/redis.conf | grep -v '^#' | grep -v '^$'")
    
    if not success:
        print(f"❌ 設定ファイルの取得に失敗しました: {output}")
        return {}
    
    # 設定をパース
    config = {}
    for line in output.split('\n'):
        if ' ' in line:
            key, *value = line.split()
            config[key] = ' '.join(value) if len(value) > 1 else value[0]
    
    return config

def check_backup_settings(config: Dict[str, Any]) -> bool:
    """バックアップ設定を確認"""
    print("\n🔍 バックアップ設定を確認中...")
    
    # バックアップ設定を取得
    save_commands = [v for k, v in config.items() if k == 'save']
    
    if not save_commands:
        print("❌ バックアップ設定が見つかりません")
        return False
    
    # バックアップ設定を表示
    print("現在のバックアップ設定:")
    for i, save_cmd in enumerate(save_commands, 1):
        print(f"  {i}. {save_cmd}")
    
    # バックアップが有効かチェック
    if any(save_cmd == '\"\"' or save_cmd == "''" for save_cmd in save_commands):
        print("❌ バックアップが無効化されています (save \"\" が設定されています)")
        return False
    
    # 推奨されるバックアップ設定
    recommended = [
        '900 1',
        '300 10',
        '60 10000'
    ]
    
    # 推奨設定と比較
    missing = []
    for rec in recommended:
        if not any(rec in save_cmd for save_cmd in save_commands):
            missing.append(rec)
    
    if missing:
        print(f"❌ 推奨されるバックアップ設定が不足しています: {', '.join(missing)}")
        return False
    
    print("✅ バックアップ設定が正しく構成されています")
    return True

def check_backup_file() -> bool:
    """バックアップファイルを確認"""
    print("\n🔍 バックアップファイルを確認中...")
    
    # バックアップファイルの存在確認
    success, output = run_command("docker compose exec redis ls -la /data/ | grep dump.rdb")
    
    if not success or 'dump.rdb' not in output:
        print("❌ バックアップファイル (dump.rdb) が見つかりません")
        return False
    
    # ファイルサイズを取得
    success, size_output = run_command("docker compose exec redis du -h /data/dump.rdb | cut -f1")
    
    if not success:
        print("❌ バックアップファイルのサイズを取得できませんでした")
        return False
    
    # ファイルの最終更新日時を取得
    success, mtime_output = run_command("docker compose exec redis stat -c '%y' /data/dump.rdb")
    
    if not success:
        print("❌ バックアップファイルの最終更新日時を取得できませんでした")
        return False
    
    # コンテナの起動時間を取得
    success, start_time_output = run_command("docker inspect -f '{{.State.StartedAt}}' redis-backup-demo")
    
    if not success:
        print("❌ コンテナの起動時間を取得できませんでした")
        return False
    
    # 日時をパース
    try:
        file_mtime = datetime.fromisoformat(mtime_output.split('.')[0])
        container_start = datetime.fromisoformat(start_time_output.split('.')[0].replace('Z', '+00:00'))
        now = datetime.now(file_mtime.tzinfo)
        
        print(f"✅ バックアップファイルが見つかりました (サイズ: {size_output})")
        print(f"    最終更新: {file_mtime}")
        print(f"    コンテナ起動から: {now - container_start} 経過")
        
        # ファイルがコンテナ起動後に更新されているか確認
        if file_mtime < container_start:
            print("❌ バックアップファイルが古いです。コンテナ起動後に更新されていません")
            print("💡 SAVE コマンドを実行して、バックアップファイルを更新してください")
            return False
            
    except Exception as e:
        print(f"❌ 日時の処理中にエラーが発生しました: {str(e)}")
        return False
    
    return True

def main() -> None:
    """メイン処理"""
    print("🚀 Redis バックアップ設定チェックを開始します...")
    
    # 1. Redis が実行中か確認
    if not check_redis_running():
        sys.exit(1)
    
    # 2. Redis の設定を確認
    config = check_redis_config()
    if not config:
        print("❌ Redis の設定を取得できませんでした")
        sys.exit(1)
    
    # 3. バックアップ設定を確認
    if not check_backup_settings(config):
        print("\n💡 修正のヒント:")
        print("1. redis.conf を編集して、以下の設定を追加してください:")
        print("   save 900 1")
        print("   save 300 10")
        print("   save 60 10000")
        print("2. 以下のコマンドで Redis を再起動してください:")
        print("   docker compose restart redis")
        sys.exit(1)
    
    # 4. バックアップファイルを確認
    if not check_backup_file():
        print("\n💡 トラブルシューティングのヒント:")
        print("1. Redis CLI で SAVE コマンドを実行して、バックアップファイルを作成してください:")
        print("   docker compose exec redis redis-cli SAVE")
        print("2. バックアップファイルのパーミッションを確認してください:")
        print("   docker compose exec redis ls -la /data/")
        sys.exit(1)
    
    # すべてのチェックに成功
    print("\n" + "=" * 60)
    print("✅ おめでとうございます！すべてのチェックに成功しました！")
    print("=" * 60)
    print("\n🎯 学習のポイント:")
    print("- Redis のバックアップ設定を理解しました")
    print("- データの永続化の重要性を学びました")
    print("- バックアップファイルの管理方法を実践しました")
    
    sys.exit(0)

if __name__ == "__main__":
    main()
</file>

<file path="ops-essentials/games/03-backup/docker-compose.yml">
version: '3.8'

services:
  redis:
    image: redis:6.2-alpine
    container_name: redis_backup_demo
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf
      - ./redis-init.sh:/docker-entrypoint-initdb.d/redis-init.sh
    command: redis-server /usr/local/etc/redis/redis.conf
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - backup_net

  redis_commander:
    image: rediscommander/redis-commander:latest
    container_name: redis_commander
    environment:
      - REDIS_HOSTS=local:redis:6379
    ports:
      - "8081:8081"
    depends_on:
      - redis
    networks:
      - backup_net

networks:
  backup_net:
    driver: bridge

volumes:
  redis_data:
</file>

<file path="ops-essentials/games/03-backup/quest.md">
# Redis バックアップ設定

## 演習の目的
この演習では、Redis のバックアップ機能を有効にし、データの永続化を設定します。
デフォルトでは無効になっているバックアップ機能を有効にして、データが永続化されるように設定します。

## 現在の状況

- Redis サーバーが起動していますが、バックアップが無効になっています
- `save ""` の設定により、定期的なバックアップが無効化されています
- データはメモリ上にのみ存在し、ディスクには保存されていません

## 課題

1. Redis の設定ファイル (`redis.conf`) を修正して、バックアップを有効にしてください
2. 以下のバックアップポリシーを設定してください：
   - 900秒（15分）以内に1回以上の変更があった場合
   - 300秒（5分）以内に10回以上の変更があった場合
   - 60秒以内に10000回以上の変更があった場合
3. 変更を適用して、バックアップが正しく作成されることを確認してください

## ステップバイステップガイド

1. 現在の設定を確認します：
   ```bash
   docker compose exec redis cat /usr/local/etc/redis/redis.conf | grep -A 5 "^save"
   ```

2. `redis.conf` ファイルを編集して、バックアップ設定を有効にします：
   ```bash
   # バックアップ設定を有効化
   save 900 1
   save 300 10
   save 60 10000
   
   # 無効化されている設定をコメントアウト
   # save ""
   ```

3. 変更を適用するために Redis を再起動します：
   ```bash
   docker compose restart redis
   ```

4. バックアップファイルが作成されているか確認します：
   ```bash
   docker compose exec redis ls -la /data/
   ```

5. データを変更して、バックアップが作成されることを確認します：
   ```bash
   # Redis CLI に接続
   docker compose exec redis redis-cli
   
   # テストデータを追加
   SET test_key "This is a test value"
   
   # 変更をディスクに同期
   SAVE
   
   # 終了
   EXIT
   
   # バックアップファイルを確認
   docker compose exec redis ls -la /data/
   ```

## ヒント

- Redis のバックアップ設定は `save` ディレクティブで制御します
- 設定を変更した後は Redis を再起動する必要があります
- バックアップファイルは `/data/dump.rdb` に作成されます

## 確認方法

演習が完了したら、以下のコマンドで正しく設定できたか確認できます：

```bash
python3 ../../../../tools/cli/game.py play 03-backup
```

## 発展課題（余裕があれば挑戦してみてください）

- バックアップファイルを別の場所にコピーするスクリプトを作成してみましょう
- 定期的にバックアップを取得する仕組みを構築してみましょう
- バックアップからデータを復元する手順を確認してみましょう
</file>

<file path="ops-essentials/games/03-backup/redis-init.sh">
#!/bin/sh
# Redis 初期化スクリプト

# コンテナ起動時に実行されるスクリプト
# サンプルデータを挿入

# Redis が起動するのを待機
until redis-cli ping &> /dev/null; do
  echo "Waiting for Redis to start..."
  sleep 1
done

# サンプルデータを挿入
echo "Inserting sample data..."
redis-cli set welcome "Hello, Redis Backup Demo!"
redis-cli lpush colors red green blue yellow
redis-cli hset user:1000 name "John Doe" email "john@example.com"

# データをディスクに同期
echo "Saving data to disk..."
redis-cli save

echo "Redis initialization complete!"
</file>

<file path="ops-essentials/games/03-backup/redis.conf">
# Redis 設定ファイル
# バックアップ設定は無効化されています（デフォルト）

# バックアップを無効化（デフォルトではコメントアウトされています）
save ""

# バックアップを有効化するには、以下のようにコメントを外して設定します
# save 900 1
# save 300 10
# save 60 10000

# バックアップファイルの保存先
dir /data

# バックアップファイル名
dbfilename dump.rdb

# データの永続化設定
appendonly no

# メモリ設定
maxmemory 100mb
maxmemory-policy allkeys-lru

# セキュリティ設定
protected-mode yes
bind 0.0.0.0
port 6379

# ログレベル
loglevel notice
logfile "/var/log/redis/redis-server.log"

# データベースの数
databases 16
</file>

<file path="ops-essentials/games/04-ha/haproxy.cfg">
global
    log /dev/log local0
    log /dev/log local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect 5000
    timeout client  50000
    timeout server  50000
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

frontend http_front
    bind *:80
    stats uri /haproxy?stats
    default_backend http_back

backend http_back
    balance roundrobin
    # バックエンドサーバー1のみが設定されています
    server web1 web1:80 check
    # バックエンドサーバー2はコメントアウトされています
    # server web2 web2:80 check

listen stats
    bind *:1936
    stats enable
    stats hide-version
    stats realm Haproxy\ Statistics
    stats uri /
    stats auth admin:admin
</file>

<file path="tools/cli/game.py">
#!/usr/bin/env python3
"""
Skillmap CLI - Ops Essentials 演習用ツール

使い方:
  python3 tools/cli/game.py play <game_id>

利用可能なゲーム:
  01-network: ネットワーク設定のデバッグ演習
"""
import subprocess
import sys
import argparse
import time
from pathlib import Path
from typing import Optional

def print_header():
    """Print the tool header."""
    print("""
    ____  _ _       _ __  __       _   _             
   / ___|(_) | __ _|  \\/  | __ _| |_| |    ___  ___
   \\___ \\| | |/ _` | |\\/| |/ _` | __| |   / _ \\/ __|
    ___) | | | (_| | |  | | (_| | |_| |__|  __/\\__ \\
   |____/|_|_|\\__,_|_|  |_|\\__,_|\\__|_____\\___||___/
   
   Ops Essentials - ネットワーク演習ツール
   """)

def get_available_games() -> list:
    """Get list of available games."""
    games_dir = Path(__file__).parent.parent.parent / "ops-essentials" / "games"
    if not games_dir.exists():
        return []
    return [d.name for d in games_dir.iterdir() if d.is_dir()]

def play_game(game_id: str) -> bool:
    """Play a specific game.
    
    Args:
        game_id: ID of the game to play
        
    Returns:
        bool: True if the game was completed successfully
    """
    game_dir = Path(__file__).parent.parent.parent / "ops-essentials" / "games" / game_id
    checker = game_dir / "checker.py"
    
    if not checker.exists():
        print(f"❌ エラー: ゲーム '{game_id}' が見つからないか、checker.py が存在しません")
        return False
    
    print(f"\n🎮 ゲームを開始します: {game_id}")
    print("-" * 50)
    
    # Check if the game has a quest file
    quest_file = game_dir / "quest.md"
    if quest_file.exists():
        with open(quest_file, 'r', encoding='utf-8') as f:
            print("\n📜 ミッション概要:")
            print("-" * 30)
            print(f.read())
    
    print("\n🔍 チェックを開始します...")
    print("-" * 50)
    
    try:
        # Run the checker with a timeout of 30 seconds
        start_time = time.time()
        result = subprocess.run(
            [sys.executable, str(checker)],
            cwd=game_dir,
            check=False,
            text=True,
            capture_output=True
        )
        elapsed_time = time.time() - start_time
        
        # Print the output
        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        
        if result.returncode == 0:
            print("\n" + "=" * 50)
            print("🎉 おめでとうございます！ クリアです！")
            print(f"⏱️  かかった時間: {elapsed_time:.1f}秒")
            print("=" * 50)
            return True
        else:
            print("\n" + "=" * 50)
            print("❌ もう一度挑戦してください")
            print("=" * 50)
            return False
            
    except subprocess.TimeoutExpired:
        print("\n🕒 チェックがタイムアウトしました。時間がかかりすぎています。")
        return False
    except Exception as e:
        print(f"\n❌ エラーが発生しました: {str(e)}")
        return False

def main():
    """Main entry point for the CLI."""
    print_header()
    
    parser = argparse.ArgumentParser(description='Skillmap CLI tool for Ops Essentials')
    subparsers = parser.add_subparsers(dest='command', help='利用可能なコマンド')
    
    # Play command
    play_parser = subparsers.add_parser('play', help='ゲームをプレイする')
    play_parser.add_argument('game_id', help='プレイするゲームのID')
    
    args = parser.parse_args()
    
    if args.command == 'play':
        available_games = get_available_games()
        if args.game_id not in available_games:
            print(f"\n❌ エラー: ゲーム '{args.game_id}' は存在しません")
            print("\n利用可能なゲーム:")
            for game in available_games:
                print(f"  - {game}")
            sys.exit(1)
            
        success = play_game(args.game_id)
        sys.exit(0 if success else 1)
    else:
        parser.print_help()
        print("\n利用可能なゲーム:")
        for game in get_available_games():
            print(f"  - {game}")
        sys.exit(1)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n👋 プログラムを終了します")
        sys.exit(0)
</file>

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*.pyc
.pytest_cache/

# Node
node_modules/
package-lock.json

# Environment variables
.env

# IDE
.vscode/
.idea/

# Local development
score.json

# Editor files
*.swp
*~
.DS_Store
</file>

<file path="docker-compose.yml">
version: "3.9"
services:
  docs:
    image: python:3.10-slim
    volumes:
      - .:/docs
    working_dir: /docs
    ports:
      - "8000:8000"
    command: >
      sh -c "pip install mkdocs-material mkdocs-mermaid2-plugin && 
             mkdocs serve --dev-addr=0.0.0.0:8000"

  game:
    depends_on: [network_lab]
    image: python:3.12-slim
    working_dir: /work
    volumes: [".:/work"]
    command: "sleep infinity"
    profiles: ["game"]

  network_lab:
    profiles: ["game"]
    image: nginx:1.25-alpine
    ports: ["8080:80"]
</file>

<file path="mkdocs.yml">
site_name: Skillmap.dev – Ops Essentials
repo_url: https://github.com/atsushi-ambo/skillmap.dev

theme:
  name: material
  palette:
    - scheme: default
      primary: indigo
      accent: light blue
  logo: img/icons/cloud.svg
  features:
    - navigation.tabs
    - navigation.expand
    - content.code.annotate

markdown_extensions:
  - admonition
  - pymdownx.superfences
  - pymdownx.tabbed
  - attr_list
  - md_in_html
  - pymdownx.snippets

plugins:
  - search
  - mermaid2:
      arguments:
        theme: default
        themeVariables:
          primaryColor: '#3f51b5'
          primaryTextColor: '#fff'
          primaryBorderColor: '#3f51b5'

nav:
  - Home: index.md
  - Ops Essentials:
      - Overview: ops-essentials/index.md
      - Level 1 – Foundations: ops-essentials/level1.md
      - Level 2 – Ops Routine: ops-essentials/level2.md
      - Level 3 – Scale & HA: ops-essentials/level3.md
      - Level 4 – Design & Cost: ops-essentials/level4.md
</file>

<file path="README.md">
# Skillmap.dev - Ops Essentials

## 概要

Skillmap.dev は、ITインフラエンジニア向けの実践的な演習環境を提供するプロジェクトです。
このリポジトリには、ネットワークやシステム運用の基本を学ぶためのドキュメントと演習コンテンツが含まれています。

## 機能

- **インタラクティブなドキュメント**: 概念を学ぶためのマークダウンベースのドキュメント
- **ハンズオン演習**: 実際の環境で試しながら学べる実践的な課題
- **Mermaid 図解**: 概念を視覚的に理解するためのダイアグラム

## クイックスタート

### 前提条件

- Docker と Docker Compose がインストールされていること

### ローカルでの実行

1. リポジトリをクローン:
   ```bash
   git clone https://github.com/atsushi-ambo/skillmap.dev.git
   cd skillmap.dev
   ```

2. ドキュメントサーバーを起動:
   ```bash
   docker compose up docs
   ```

3. ブラウザで [http://localhost:8000](http://localhost:8000) にアクセス

## ドキュメントの構成

- **Ops Essentials**: インフラ運用の基礎からコスト設計まで
  - Level 1: 基礎知識とネットワーク
  - Level 2: 運用業務の基本
  - Level 3: スケーリングと高可用性
  - Level 4: 設計とコスト最適化

2. スライドを表示:
   ```bash
   docker compose --profile slides up
   ```
   ブラウザで http://localhost:1948 を開きます

3. 演習を開始:
   ```bash
   # ゲーム環境を起動
   docker compose --profile game up -d
   
   # 演習を開始
   python3 tools/cli/game.py play 01-network
   ```

## 利用可能な演習

### 1. ネットワーク設定のデバッグ

- **目的**: Docker のネットワーク設定とポートマッピングを学ぶ
- **学習内容**:
  - コンテナのポートマッピング
  - Nginx の基本的な設定
  - ネットワークトラブルシューティング

## トラブルシューティング

- コンテナが起動しない場合:
  ```bash
  # ログを確認
  docker logs skillmapdev-network_lab-1
  
  # コンテナを再起動
  docker compose --profile game down
  docker compose --profile game up -d
  ```

- ポートが競合する場合:
  ```bash
  # 使用中のポートを確認
  lsof -i :8080
  
  # 別のポートを使用する場合は、docker-compose.yml を編集
  ```

## ライセンス

MIT License
</file>

</files>
